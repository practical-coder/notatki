<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Notatki</title>
    <link>https://practical-coder.github.io/notatki/post/</link>
    <description>Recent content in Posts on Notatki</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-pl</language>
    <copyright>©2016 Jac</copyright>
    <lastBuildDate>Sat, 16 Jul 2016 22:35:19 +0200</lastBuildDate>
    <atom:link href="https://practical-coder.github.io/notatki/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker Remote API - poligon</title>
      <link>https://practical-coder.github.io/notatki/post/docker-remote-api-poligon/</link>
      <pubDate>Sat, 16 Jul 2016 22:35:19 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/docker-remote-api-poligon/</guid>
      <description>

&lt;h2 id=&#34;połączenie-z-gniazdem-unixowym&#34;&gt;Połączenie z gniazdem unixowym&lt;/h2&gt;

&lt;p&gt;Domyślnie usługa Docker zainstalowana na linuxie umożliwia komunikację z
Docker Remote API używając gniazda &lt;code&gt;/var/run/docker.sock&lt;/code&gt;. Podobnie jest
w przypadku instalacji Docker dla Mac wykorzystującej xhyvie.&lt;/p&gt;

&lt;h3 id=&#34;konsola-curl&#34;&gt;konsola - curl&lt;/h3&gt;

&lt;p&gt;Do przetestowania odpowiedzi demona wykorzystujemy najpierw klienta &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s --unix-socket /var/run/docker.sock http:/info | jq &#39;.ContainersRunning&#39;
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Za pomocą &lt;code&gt;jq&lt;/code&gt; ograniczono odpowiedź &lt;code&gt;/info&lt;/code&gt; do wartości klucza
&lt;code&gt;.ContainersRunning&lt;/code&gt;, czyli &lt;code&gt;2&lt;/code&gt;.
Należy zwrócić uwagę na &lt;code&gt;http:/info&lt;/code&gt; i pojedynczy znak &lt;code&gt;/&lt;/code&gt;. Jeżeli przez
pomyłkę użyjemy &lt;code&gt;http://info&lt;/code&gt; dostaniemy odpowiedź:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s --unix-socket /var/run/docker.sock http://info | jq
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;message&amp;quot;: &amp;quot;page not found&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s --unix-socket /var/run/docker.sock http:/containers/json?limit=1 | jq
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
  {
    &amp;quot;Id&amp;quot;: &amp;quot;e0649129b761be2207627b0527ba17534180e4f0e74a4f2b0d6a1c9af29a445c&amp;quot;,
    &amp;quot;Names&amp;quot;: [
      &amp;quot;/romantic_colden&amp;quot;
    ],
    &amp;quot;Image&amp;quot;: &amp;quot;basics:v1&amp;quot;,
    &amp;quot;ImageID&amp;quot;: &amp;quot;sha256:ff3eac843704765ab36cdd5e47d790c9fc131b7441e91a3e102d757241208684&amp;quot;,
    &amp;quot;Command&amp;quot;: &amp;quot;/go/bin/basics_lin&amp;quot;,
    &amp;quot;Created&amp;quot;: 1468009653,
    &amp;quot;Ports&amp;quot;: [],
    &amp;quot;Labels&amp;quot;: {},
    &amp;quot;State&amp;quot;: &amp;quot;exited&amp;quot;,
    &amp;quot;Status&amp;quot;: &amp;quot;Exited (0) 32 hours ago&amp;quot;,
    &amp;quot;HostConfig&amp;quot;: {
      &amp;quot;NetworkMode&amp;quot;: &amp;quot;default&amp;quot;
    },
    &amp;quot;NetworkSettings&amp;quot;: {
      &amp;quot;Networks&amp;quot;: {
        &amp;quot;bridge&amp;quot;: {
          &amp;quot;IPAMConfig&amp;quot;: null,
          &amp;quot;Links&amp;quot;: null,
          &amp;quot;Aliases&amp;quot;: null,
          &amp;quot;NetworkID&amp;quot;: &amp;quot;85b9fda269593cd1af519f92593dd49027ed7cc97b4dbf8258498d43313ac3d7&amp;quot;,
          &amp;quot;EndpointID&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;Gateway&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;IPAddress&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;IPPrefixLen&amp;quot;: 0,
          &amp;quot;IPv6Gateway&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;GlobalIPv6Address&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;GlobalIPv6PrefixLen&amp;quot;: 0,
          &amp;quot;MacAddress&amp;quot;: &amp;quot;&amp;quot;
        }
      }
    },
    &amp;quot;Mounts&amp;quot;: []
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;go-engine-api&#34;&gt;Go - engine-api&lt;/h3&gt;

&lt;p&gt;Teraz podobna operacja, tylko za pomocą engine-api, nie wypisujemy wszystkich
informacji oraz używamy formatu tekstowego zamiast JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/docker/engine-api/client&amp;quot;
	&amp;quot;github.com/docker/engine-api/types&amp;quot;
	&amp;quot;golang.org/x/net/context&amp;quot;
)

func main() {
	defaultHeaders := map[string]string{&amp;quot;User-Agent&amp;quot;: &amp;quot;engine-api-cli-1.0&amp;quot;}
	cli, err := client.NewClient(&amp;quot;unix:///var/run/docker.sock&amp;quot;, &amp;quot;v1.24&amp;quot;, nil, defaultHeaders)
	if err != nil {
		panic(err)
	}

	options := types.ContainerListOptions{Latest: true, Limit: 1}
	containers, err := cli.ContainerList(context.Background(), options)
	if err != nil {
		panic(err)
	}

	for _, c := range containers {
		fmt.Println(c.ID, c.Names, c.Created, c.Image, c.Ports, c.State, c.Status)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Po skompilowaniu i uruchomieniu otrzymujemy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./dockering
e0649129b761be2207627b0527ba17534180e4f0e74a4f2b0d6a1c9af29a445c [/romantic_colden] 1468009653 basics:v1 [] exited Exited (0) 32 hours ago
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bez rewelacji, ale sprawdziliśmy połączenie z poziomu Go, zawsze coś.&lt;/p&gt;

&lt;h2 id=&#34;połączenie-na-porcie-tcp-używając-tls&#34;&gt;Połączenie na porcie TCP używając TLS&lt;/h2&gt;

&lt;h3 id=&#34;konsola-curl-1&#34;&gt;konsola - curl&lt;/h3&gt;

&lt;p&gt;Systemy produkcyjne, a także Docker Machine, wystawiają API protokołem https na
porcie TCP, domyślnie, o numerze &lt;code&gt;2376&lt;/code&gt;.
Na próbę połączmy się z API lokalnego Docker Machine, jeżeli środowisko jest prawidłowo
skonfigurowane powinna być dostępna zmienna &lt;code&gt;DOCKER_CERT_PATH&lt;/code&gt;, domyślny adres IP Docker Machine to &lt;code&gt;192.168.99.100&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl --cert $DOCKER_CERT_PATH/cert.pem --key $DOCKER_CERT_PATH/key.pem https://192.168.99.100:2376/info
curl: (58) SSL: Can&#39;t load the certificate &amp;quot;/Users/jac/.docker/machine/machines/default/cert.pem&amp;quot; and its private key: OSStatus -25299
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Niestety jest problem, jedno z proponowanych rozwiązań, to inny format
przekazywania klucza i certyfikatu.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ openssl pkcs12 -export -in $DOCKER_CERT_PATH/cert.pem -inkey $DOCKER_CERT_PATH/key.pem -out $DOCKER_CERT_PATH/cert.pfx -password pass:niejawne
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Przetestujmy czy to działa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s --cert $DOCKER_CERT_PATH/cert.pfx --cacert $DOCKER_CERT_PATH/ca.pem --pass niejawne https://192.168.99.100:2376/info | jq &#39;.ContainersRunning&#39;
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zapytanie się powiodło. Na Docker Machine działa jeden kontener.&lt;/p&gt;

&lt;h3 id=&#34;go-engine-api-1&#34;&gt;Go - engine-api&lt;/h3&gt;

&lt;p&gt;Przetestujmy to samo z Go. Sprawę ułatwia &lt;code&gt;NewEnvClient&lt;/code&gt;. Dane do połączenia
brane są ze zmiennych środowiskowych.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;github.com/docker/engine-api/client&amp;quot;
	&amp;quot;github.com/docker/engine-api/types&amp;quot;
	&amp;quot;golang.org/x/net/context&amp;quot;
)

func main() {
	os.Setenv(&amp;quot;DOCKER_HOST&amp;quot;, &amp;quot;https://192.168.99.100:2376&amp;quot;)
	os.Setenv(&amp;quot;DOCKER_API_VERSION&amp;quot;, &amp;quot;v1.23&amp;quot;)
	os.Setenv(&amp;quot;DOCKER_CERT_PATH&amp;quot;, &amp;quot;/Users/jac/.docker/machine/machines/default&amp;quot;)

	cli, err := client.NewEnvClient()
	if err != nil {
		panic(err)
	}

	options := types.ContainerListOptions{Latest: true, Limit: 1}
	containers, err := cli.ContainerList(context.Background(), options)
	if err != nil {
		panic(err)
	}

	for _, c := range containers {
		fmt.Println(c.ID, c.Names, c.Created, c.Image, c.Ports, c.State, c.Status)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Docker dla Mac na lokalnym używa API w wersj v1.24.
Docker Machine na lokalnym systemie jest w starszej wersji API: v1.23. W kodzie ustawiamy odpowiednią
zmienną środowiskową, tak, żeby wersja klienta nie była nowsza niż wersja serwera.
Po skompilowaniu, uruchamiamy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go build
$ ./dockering
28884f52d089b869559b3305f1fb1c6c450d69be76f3bb56fbb691bd7b6bcf65 [/hungry_tesla] 1467147773 szuka_dev [] exited Exited (2) 2 weeks ago
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otrzymaliśmy dane o kontenerze na Docker Machine. Wszystko poszło zgodnie z planem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go przykład json api z użyciem Iris oraz GORM</title>
      <link>https://practical-coder.github.io/notatki/post/go-przyklad-json-api-z-uzyciem-iris-oraz-gorm/</link>
      <pubDate>Sun, 19 Jun 2016 18:59:26 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/go-przyklad-json-api-z-uzyciem-iris-oraz-gorm/</guid>
      <description>

&lt;h2 id=&#34;organizacja-kodu&#34;&gt;Organizacja kodu&lt;/h2&gt;

&lt;p&gt;Zbudujmy przykładowe API do tworzenia notatek i tagów. Dane składowane są w
PostgreSQL, do uproszczenia wyciągania danych z bazy użyty zostanie GORM. Natomiast
do ułatwienia komunikacji HTTP oraz serializacji do formatu JSON
wykorzystany zostanie framework Iris.&lt;/p&gt;

&lt;p&gt;Struktura plików aplikacji:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;notes (master) $ tree
.
├── db
│   └── pg
│       └── pg.go
├── main.go
├── note
│   ├── controller.go
│   └── model.go
└── tag
    ├── controller.go
    └── model.go

4 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plik &lt;strong&gt;&lt;code&gt;main.go&lt;/code&gt;&lt;/strong&gt; stanowi punkt wejścia aplikacji. Definiowane są tam
mapowania ścieżek url na odpowiednie metody. Uruchamiany jest tam też
serwer iris z możliwością zmiany domyślnego portu flagą z lini poleceń.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;flag&amp;quot;
    &amp;quot;notes/note&amp;quot;
    &amp;quot;notes/tag&amp;quot;

    &amp;quot;github.com/kataras/iris&amp;quot;
)

var port string

func main() {
    flag.Parse()
    flag.StringVar(&amp;amp;port, &amp;quot;p&amp;quot;, &amp;quot;8181&amp;quot;, &amp;quot;Listen on TCP port: -p &amp;lt;PORT_NUMBER&amp;gt;&amp;quot;)

    // Notes
    iris.Get(&amp;quot;/notes&amp;quot;, note.List)
    iris.Post(&amp;quot;/notes&amp;quot;, note.Create)
    iris.Get(&amp;quot;/notes/:id&amp;quot;, note.Show)
    iris.Delete(&amp;quot;/notes/:id&amp;quot;, note.Destroy)

    // Tags
    iris.Get(&amp;quot;/tags&amp;quot;, tag.List)
    iris.Get(&amp;quot;/tags/:id&amp;quot;, tag.Show)

    iris.Listen(&amp;quot;:&amp;quot; + port)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;połączenie-z-bazą-danych&#34;&gt;Połączenie z bazą danych&lt;/h2&gt;

&lt;p&gt;W pliku &lt;strong&gt;&lt;code&gt;db/pg/pg.go&lt;/code&gt;&lt;/strong&gt; otwieramy połączenie z bazą używając jako ORM
bibilioteki &lt;strong&gt;GORM&lt;/strong&gt; oraz sterownika bazy PostgreSQL, &lt;strong&gt;pq&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package pg

import (
    &amp;quot;log&amp;quot;

    &amp;quot;github.com/jinzhu/gorm&amp;quot;
    _ &amp;quot;github.com/lib/pq&amp;quot;
)

var DB *gorm.DB

func init() {
    var err error

    DB, err = gorm.Open(&amp;quot;postgres&amp;quot;, &amp;quot;user=&amp;lt;User&amp;gt; host=localhost password=&amp;lt;Pass&amp;gt; dbname=&amp;lt;Db&amp;gt; sslmode=disable&amp;quot;)
    if err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paczka-note&#34;&gt;Paczka note&lt;/h2&gt;

&lt;p&gt;Katalog &lt;strong&gt;/note&lt;/strong&gt; zawiera cały kod odpowiedzialny za Notatkę. W tak prostym
przykładzie kod modelu oraz kontrolera należą do tej samej paczki &lt;strong&gt;&lt;code&gt;package note&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;model&#34;&gt;Model&lt;/h3&gt;

&lt;p&gt;Kod modelu znajduje się w pliku &lt;strong&gt;/note/model.go&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package note

import (
    &amp;quot;notes/db/pg&amp;quot;
    &amp;quot;time&amp;quot;
)

type Note struct {
    ID        uint      `json:&amp;quot;id&amp;quot;`
    CreatedAt time.Time `json:&amp;quot;created_at&amp;quot;`
    UpdatedAt time.Time `json:&amp;quot;updated_at&amp;quot;`
    Title     string    `json:&amp;quot;title&amp;quot;`
    Text      string    `json:&amp;quot;text&amp;quot;`
}

type Notes struct {
    Notes []Note `json:&amp;quot;notes&amp;quot;`
}

func find(id int) Note {
    note := Note{}
    pg.DB.Where(&amp;quot;id = ?&amp;quot;, id).First(&amp;amp;note)
    return note
}

func destroy(id int) {
    pg.DB.Delete(Note{}, &amp;quot;id = ?&amp;quot;, id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kontroler&#34;&gt;Kontroler&lt;/h3&gt;

&lt;p&gt;Plik &lt;strong&gt;/note/controller.go&lt;/strong&gt; zawiera kod kontrolera:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package note

import (
    &amp;quot;log&amp;quot;
    &amp;quot;notes/db/pg&amp;quot;

    &amp;quot;github.com/kataras/iris&amp;quot;
)

func List(c *iris.Context) {
    notes := Notes{}
    pg.DB.Find(&amp;amp;notes.Notes)
    c.JSON(iris.StatusOK, notes)
}

func Show(c *iris.Context) {
    id, err := c.ParamInt(&amp;quot;id&amp;quot;)
    if err != nil {
        log.Println(err)
    }

    note := find(id)
    if note.ID == 0 {
        c.JSON(iris.StatusNotFound, map[string]string{&amp;quot;error&amp;quot;: &amp;quot;Note not found.&amp;quot;})
    } else {
        c.JSON(iris.StatusOK, note)
    }
}

func Create(c *iris.Context) {
    var note Note

    err := c.ReadJSON(&amp;amp;note)
    if err != nil {
        log.Println(err)
    }

    pg.DB.Create(&amp;amp;note)
    c.JSON(iris.StatusOK, note)
}

func Destroy(c *iris.Context) {
    id, err := c.ParamInt(&amp;quot;id&amp;quot;)
    if err != nil {
        log.Println(err)
    }
    destroy(id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paczka-tag&#34;&gt;Paczka tag&lt;/h2&gt;

&lt;p&gt;W katalogu &lt;strong&gt;/tag&lt;/strong&gt; znajduje się kod dotyczący Tagów.&lt;/p&gt;

&lt;h3 id=&#34;model-1&#34;&gt;Model&lt;/h3&gt;

&lt;p&gt;Zawartość pliku &lt;strong&gt;/tag/model.go&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package tag

import (
    &amp;quot;notes/db/pg&amp;quot;
    &amp;quot;time&amp;quot;
)

type Tag struct {
    ID        uint      `json:&amp;quot;id&amp;quot;`
    CreatedAt time.Time `json:&amp;quot;created_at&amp;quot;`
    UpdatedAt time.Time `json:&amp;quot;updated_at&amp;quot;`
    Name      string    `json:&amp;quot;name&amp;quot;`
}

type Tags struct {
    Tags []Tag `json:&amp;quot;tags&amp;quot;`
}

func find(id int) Tag {
    tag := Tag{}
    pg.DB.Where(&amp;quot;id = ?&amp;quot;, id).First(&amp;amp;tag)
    return tag
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kontroler-1&#34;&gt;Kontroler&lt;/h3&gt;

&lt;p&gt;Plik &lt;strong&gt;/tag/controller.go&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package tag

import (
    &amp;quot;log&amp;quot;
    &amp;quot;notes/db/pg&amp;quot;

    &amp;quot;github.com/kataras/iris&amp;quot;
)

func List(c *iris.Context) {
    tags := Tags{}
    pg.DB.Find(&amp;amp;tags.Tags)
    c.JSON(iris.StatusOK, tags)
}

func Show(c *iris.Context) {
    id, err := c.ParamInt(&amp;quot;id&amp;quot;)
    if err != nil {
        log.Println(err)
    }

    tag := find(id)
    if tag.ID == 0 {
        c.JSON(iris.StatusNotFound, map[string]string{&amp;quot;error&amp;quot;: &amp;quot;Tag not found.&amp;quot;})
    } else {
        c.JSON(iris.StatusOK, tag)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;podsumowanie&#34;&gt;Podsumowanie&lt;/h2&gt;

&lt;p&gt;Jak widać Iris sporo upraszcza, standardowe handlery z paczki net/http
przyjmują dwa parametry, request oraz response. W Iris to jest tylko jeden
wskaźnik na kontekst. Odczytanie parametru w url, konwersja do typu
całkowitego, odczytanie formatu json z body zapytania POST, zwrócenie jsona
z odpowiednim nagłówkiem statusu i wiele wiele innych standardowych operacji
staje się dużo łatwiejszych.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Historia poleceń, czas wykonania komendy</title>
      <link>https://practical-coder.github.io/notatki/post/historia-polecen-czas-wykonania-komendy/</link>
      <pubDate>Sun, 19 Jun 2016 18:57:32 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/historia-polecen-czas-wykonania-komendy/</guid>
      <description>&lt;p&gt;Domyślnie pierwsza kolumna wpisu historii powłoki zawiera tylko id wykonanej komendy. Nie ma jednak informacji o czasie jej wykonania.
Aby taką informację dodać, należy ustawić format czasu jaki powinien być wpisywany w zmienną środowiskową &lt;strong&gt;HISTTIMEFORMAT&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;HISTTIMEFORMAT=&#39;%H:%M:%S %d-%m-%Y  &#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>OS X usługi nasłuchujące</title>
      <link>https://practical-coder.github.io/notatki/post/osx-uslugi-nasluchujace/</link>
      <pubDate>Sun, 19 Jun 2016 18:55:16 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/osx-uslugi-nasluchujace/</guid>
      <description>&lt;p&gt;W OS X polecenie &lt;strong&gt;&lt;code&gt;netstat&lt;/code&gt;&lt;/strong&gt; zachowuje się inaczej niż pod Linuxem. Do wypisania usług nasłuchujących na portach tcp lokalnej maszyny można użyć polecenia &lt;strong&gt;&lt;code&gt;lsof&lt;/code&gt;&lt;/strong&gt;. Przykładowo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo lsof -i tcp -nP -stcp:listen
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;COMMAND    PID   USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
nginx       57   root    8u  IPv4 0x44ebc4a200674587      0t0  TCP *:8080 (LISTEN)
nginx       57   root    9u  IPv4 0x44ebc4a2006721a7      0t0  TCP *:80 (LISTEN)
nxserver.   78     nx   13u  IPv4 0x44ebc4a201602397      0t0  TCP 127.0.0.1:23998 (LISTEN)
ss_conn_s   79   root    7u  IPv4 0x44ebc4a200673c8f      0t0  TCP 127.0.0.1:50911 (LISTEN)
nginx      222 nobody    8u  IPv4 0x44ebc4a200674587      0t0  TCP *:8080 (LISTEN)
nginx      222 nobody    9u  IPv4 0x44ebc4a2006721a7      0t0  TCP *:80 (LISTEN)
nxd        266     nx    3u  IPv4 0x44ebc4a200673397      0t0  TCP *:4000 (LISTEN)
nxd        266     nx    4u  IPv6 0x44ebc4a2015fbaaf      0t0  TCP *:4000 (LISTEN)
mongod     427    jac    6u  IPv4 0x44ebc4a202ae5587      0t0  TCP 127.0.0.1:27017 (LISTEN)
java       431    jac  115u  IPv6 0x44ebc4a2015fafef      0t0  TCP 127.0.0.1:9300 (LISTEN)
java       431    jac  144u  IPv6 0x44ebc4a20a9f600f      0t0  TCP 127.0.0.1:9200 (LISTEN)
redis-ser  433    jac    4u  IPv4 0x44ebc4a202a868af      0t0  TCP 127.0.0.1:6379 (LISTEN)
postgres   443    jac    5u  IPv6 0x44ebc4a2015fc56f      0t0  TCP [::1]:5432 (LISTEN)
postgres   443    jac    6u  IPv6 0x44ebc4a2015fc00f      0t0  TCP [fe80:1::1]:5432 (LISTEN)
postgres   443    jac    7u  IPv4 0x44ebc4a202a87a9f      0t0  TCP 127.0.0.1:5432 (LISTEN)
SpotifyWe  444    jac    6u  IPv4 0x44ebc4a202ae5e7f      0t0  TCP 127.0.0.1:4370 (LISTEN)
SpotifyWe  444    jac    7u  IPv4 0x44ebc4a202a88c8f      0t0  TCP 127.0.0.1:4380 (LISTEN)
nxserver.  827     nx    4u  IPv4 0x44ebc4a20a407397      0t0  TCP 127.0.0.1:20000 (LISTEN)
nxnode.bi  868    jac   15u  IPv4 0x44ebc4a20a4f6e7f      0t0  TCP 127.0.0.1:12002 (LISTEN)
nxnode.bi  868    jac   17u  IPv6 0x44ebc4a2015fb54f      0t0  TCP [::1]:7002 (LISTEN)
nxnode.bi  868    jac   18u  IPv4 0x44ebc4a20a50b397      0t0  TCP 127.0.0.1:7002 (LISTEN)
nxclient   897    jac    6u  IPv4 0x44ebc4a20a50ce7f      0t0  TCP 127.0.0.1:25002 (LISTEN)
Python    1562    jac   11u  IPv4 0x44ebc4a20a4f4a9f      0t0  TCP 127.0.0.1:50120 (LISTEN)
ruby      1879    jac   10u  IPv4 0x44ebc4a203053c8f      0t0  TCP 127.0.0.1:50274 (LISTEN)
ruby      1881    jac   10u  IPv4 0x44ebc4a203052a9f      0t0  TCP 127.0.0.1:50276 (LISTEN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Informacje do przejrzenia są mniej więcej odpowiednikiem starego i wypróbowanego&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netstat -lntp
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:5666            0.0.0.0:*               LISTEN      846/nrpe
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      17504/sshd
tcp        0      0 0.0.0.0:65432           0.0.0.0:*               LISTEN      9137/memcached
tcp6       0      0 :::22                   :::*                    LISTEN      17504/sshd
tcp6       0      0 :::65432                :::*                    LISTEN      9137/memcached
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vim przywrócenie autouzupełniania</title>
      <link>https://practical-coder.github.io/notatki/post/vim-przywrocenie-autouzupelniania/</link>
      <pubDate>Sun, 19 Jun 2016 18:53:16 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/vim-przywrocenie-autouzupelniania/</guid>
      <description>&lt;p&gt;Po aktualizacji Vim przestało działać autouzupełnianie. Wymagane jest w takim
przypadku przejście do katalogu wtyczki YouCompleteMe, oraz odpalenie kompilacji ze wsparciem dla języka C oraz Go.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~ $ cd  .vim/bundle/YouCompleteMe/
YouCompleteMe (master) $ ./install.py --clang-completer --gocode-completer
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go: odbiorca metody, przykłady</title>
      <link>https://practical-coder.github.io/notatki/post/go-odbiorca-metody-przyk%C5%82ady/</link>
      <pubDate>Sun, 19 Jun 2016 09:03:31 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/go-odbiorca-metody-przyk%C5%82ady/</guid>
      <description>&lt;p&gt;W Go po słowie kluczowym &lt;strong&gt;&lt;code&gt;func&lt;/code&gt;&lt;/strong&gt;, a przed nazwą metody, możemy określić jej odbiorcę.
Jeżeli obiekt nie będzie modyfikowany, odbiorcę metody określamy przez jego wartość.
W metodach &lt;strong&gt;&lt;code&gt;Len()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;Cap()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;IsEmpty()&lt;/code&gt;&lt;/strong&gt; oraz &lt;strong&gt;&lt;code&gt;Top()&lt;/code&gt;&lt;/strong&gt; odbiorcą jest &lt;strong&gt;&lt;code&gt;Stack&lt;/code&gt;&lt;/strong&gt;. Potrzebują one informacji o aktualnym stanie obiektu tylko do odczytu.
Natomiast jeżeli metoda modyfikuje obiekt, wtedy odbiorca określany jest wskaźnikiem do obiektu.
Tak się dzieje w metodach &lt;strong&gt;&lt;code&gt;Push()&lt;/code&gt;&lt;/strong&gt; i &lt;strong&gt;&lt;code&gt;Pop()&lt;/code&gt;&lt;/strong&gt;. Tam odbiorcą jest &lt;strong&gt;&lt;code&gt;*Stack&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package stack

import &amp;quot;errors&amp;quot;

type Stack []interface{}

func (stack Stack) Len() int {
    return len(stack)
}

func (stack Stack) Cap() int {
    return cap(stack)
}

func (stack Stack) IsEmpty() bool {
    return len(stack) == 0
}

func (stack Stack) Top() (interface{}, error) {
    if stack.IsEmpty() {
        return nil, errors.New(&amp;quot;Cannot Top() an empty stack&amp;quot;)
    } else {
        return stack[len(stack)-1], nil
    }
}

func (stack *Stack) Push(x interface{}) {
    *stack = append(*stack, x)
}

func (stack *Stack) Pop() (interface{}, error) {
    tempStack := *stack
    if tempStack.IsEmpty() {
        return nil, errors.New(&amp;quot;Cannot Pop() an empty stack&amp;quot;)
    } else {
        item := tempStack[len(tempStack)-1]
        *stack = tempStack[:len(tempStack)-1]
        return item, nil
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Testing notes with curl</title>
      <link>https://practical-coder.github.io/notatki/post/testing-notes-with-curl/</link>
      <pubDate>Sun, 19 Jun 2016 08:11:03 +0200</pubDate>
      
      <guid>https://practical-coder.github.io/notatki/post/testing-notes-with-curl/</guid>
      <description>&lt;p&gt;To test creating notes with api, use sample &lt;code&gt;note.json&lt;/code&gt; in main
directory and post it with curl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat note.json | c -XPOST http://localhost:8181/notes -d @-
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>