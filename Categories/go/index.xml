<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Notatki</title>
    <link>http://practical-coder.github.io/notatki/categories/go/</link>
    <description>Recent content in Go on Notatki</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-pl</language>
    <lastBuildDate>Sun, 19 Jun 2016 13:17:21 +0200</lastBuildDate>
    <atom:link href="http://practical-coder.github.io/notatki/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go: przykład JSON api za pomocą Iris oraz GORM</title>
      <link>http://practical-coder.github.io/notatki/post/go-notatki-przyk%C5%82ad-json-api-za-pomoca%CC%A8-iris-oraz-gorm/</link>
      <pubDate>Sun, 19 Jun 2016 13:17:21 +0200</pubDate>
      
      <guid>http://practical-coder.github.io/notatki/post/go-notatki-przyk%C5%82ad-json-api-za-pomoca%CC%A8-iris-oraz-gorm/</guid>
      <description>

&lt;h2 id=&#34;organizacja-kodu&#34;&gt;Organizacja kodu&lt;/h2&gt;

&lt;p&gt;Zbudujmy przykładowe API do tworzenia notatek i tagów. Dane składowane są w
PostgreSQL, do uproszczenia wyciągania danych z bazy użyty zostanie GORM. Natomiast
do ułatwienia komunikacji HTTP oraz serializacji do formatu JSON
wykorzystany zostanie framework Iris.&lt;/p&gt;

&lt;p&gt;Struktura plików aplikacji:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;notes (master) $ tree
.
├── db
│   └── pg
│       └── pg.go
├── main.go
├── note
│   ├── controller.go
│   └── model.go
└── tag
    ├── controller.go
    └── model.go

4 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plik &lt;strong&gt;&lt;code&gt;main.go&lt;/code&gt;&lt;/strong&gt; stanowi punkt wejścia aplikacji. Definiowane są tam
mapowania ścieżek url na odpowiednie metody. Uruchamiany jest tam też
serwer iris z możliwością zmiany domyślnego portu flagą z lini poleceń.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;flag&amp;quot;
    &amp;quot;notes/note&amp;quot;
    &amp;quot;notes/tag&amp;quot;

    &amp;quot;github.com/kataras/iris&amp;quot;
)

var port string

func main() {
    flag.Parse()
    flag.StringVar(&amp;amp;port, &amp;quot;p&amp;quot;, &amp;quot;8181&amp;quot;, &amp;quot;Listen on TCP port: -p &amp;lt;PORT_NUMBER&amp;gt;&amp;quot;)

    // Notes
    iris.Get(&amp;quot;/notes&amp;quot;, note.List)
    iris.Post(&amp;quot;/notes&amp;quot;, note.Create)
    iris.Get(&amp;quot;/notes/:id&amp;quot;, note.Show)
    iris.Delete(&amp;quot;/notes/:id&amp;quot;, note.Destroy)

    // Tags
    iris.Get(&amp;quot;/tags&amp;quot;, tag.List)
    iris.Get(&amp;quot;/tags/:id&amp;quot;, tag.Show)

    iris.Listen(&amp;quot;:&amp;quot; + port)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;połączenie-z-bazą-danych&#34;&gt;Połączenie z bazą danych&lt;/h2&gt;

&lt;p&gt;W pliku &lt;strong&gt;&lt;code&gt;db/pg/pg.go&lt;/code&gt;&lt;/strong&gt; otwieramy połączenie z bazą używając jako ORM
bibilioteki &lt;strong&gt;GORM&lt;/strong&gt; oraz sterownika bazy PostgreSQL, &lt;strong&gt;pq&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package pg

import (
    &amp;quot;log&amp;quot;

    &amp;quot;github.com/jinzhu/gorm&amp;quot;
    _ &amp;quot;github.com/lib/pq&amp;quot;
)

var DB *gorm.DB

func init() {
    var err error

    DB, err = gorm.Open(&amp;quot;postgres&amp;quot;, &amp;quot;user=&amp;lt;User&amp;gt; host=localhost password=&amp;lt;Pass&amp;gt; dbname=&amp;lt;Db&amp;gt; sslmode=disable&amp;quot;)
    if err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paczka-note&#34;&gt;Paczka note&lt;/h2&gt;

&lt;p&gt;Katalog &lt;strong&gt;/note&lt;/strong&gt; zawiera cały kod odpowiedzialny za Notatkę. W tak prostym
przykładzie kod modelu oraz kontrolera należą do tej samej paczki &lt;strong&gt;&lt;code&gt;package note&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;model&#34;&gt;Model&lt;/h3&gt;

&lt;p&gt;Kod modelu znajduje się w pliku &lt;strong&gt;/note/model.go&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package note

import (
    &amp;quot;notes/db/pg&amp;quot;
    &amp;quot;time&amp;quot;
)

type Note struct {
    ID        uint      `json:&amp;quot;id&amp;quot;`
    CreatedAt time.Time `json:&amp;quot;created_at&amp;quot;`
    UpdatedAt time.Time `json:&amp;quot;updated_at&amp;quot;`
    Title     string    `json:&amp;quot;title&amp;quot;`
    Text      string    `json:&amp;quot;text&amp;quot;`
}

type Notes struct {
    Notes []Note `json:&amp;quot;notes&amp;quot;`
}

func find(id int) Note {
    note := Note{}
    pg.DB.Where(&amp;quot;id = ?&amp;quot;, id).First(&amp;amp;note)
    return note
}

func destroy(id int) {
    pg.DB.Delete(Note{}, &amp;quot;id = ?&amp;quot;, id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kontroler&#34;&gt;Kontroler&lt;/h3&gt;

&lt;p&gt;Plik &lt;strong&gt;/note/controller.go&lt;/strong&gt; zawiera kod kontrolera:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package note

import (
    &amp;quot;log&amp;quot;
    &amp;quot;notes/db/pg&amp;quot;

    &amp;quot;github.com/kataras/iris&amp;quot;
)

func List(c *iris.Context) {
    notes := Notes{}
    pg.DB.Find(&amp;amp;notes.Notes)
    c.JSON(iris.StatusOK, notes)
}

func Show(c *iris.Context) {
    id, err := c.ParamInt(&amp;quot;id&amp;quot;)
    if err != nil {
        log.Println(err)
    }

    note := find(id)
    if note.ID == 0 {
        c.JSON(iris.StatusNotFound, map[string]string{&amp;quot;error&amp;quot;: &amp;quot;Note not found.&amp;quot;})
    } else {
        c.JSON(iris.StatusOK, note)
    }
}

func Create(c *iris.Context) {
    var note Note

    err := c.ReadJSON(&amp;amp;note)
    if err != nil {
        log.Println(err)
    }

    pg.DB.Create(&amp;amp;note)
    c.JSON(iris.StatusOK, note)
}

func Destroy(c *iris.Context) {
    id, err := c.ParamInt(&amp;quot;id&amp;quot;)
    if err != nil {
        log.Println(err)
    }
    destroy(id)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paczka-tag&#34;&gt;Paczka tag&lt;/h2&gt;

&lt;p&gt;W katalogu &lt;strong&gt;/tag&lt;/strong&gt; znajduje się kod dotyczący Tagów.&lt;/p&gt;

&lt;h3 id=&#34;model-1&#34;&gt;Model&lt;/h3&gt;

&lt;p&gt;Zawartość pliku &lt;strong&gt;/tag/model.go&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package tag

import (
    &amp;quot;notes/db/pg&amp;quot;
    &amp;quot;time&amp;quot;
)

type Tag struct {
    ID        uint      `json:&amp;quot;id&amp;quot;`
    CreatedAt time.Time `json:&amp;quot;created_at&amp;quot;`
    UpdatedAt time.Time `json:&amp;quot;updated_at&amp;quot;`
    Name      string    `json:&amp;quot;name&amp;quot;`
}

type Tags struct {
    Tags []Tag `json:&amp;quot;tags&amp;quot;`
}

func find(id int) Tag {
    tag := Tag{}
    pg.DB.Where(&amp;quot;id = ?&amp;quot;, id).First(&amp;amp;tag)
    return tag
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kontroler-1&#34;&gt;Kontroler&lt;/h3&gt;

&lt;p&gt;Plik &lt;strong&gt;/tag/controller.go&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package tag

import (
    &amp;quot;log&amp;quot;
    &amp;quot;notes/db/pg&amp;quot;

    &amp;quot;github.com/kataras/iris&amp;quot;
)

func List(c *iris.Context) {
    tags := Tags{}
    pg.DB.Find(&amp;amp;tags.Tags)
    c.JSON(iris.StatusOK, tags)
}

func Show(c *iris.Context) {
    id, err := c.ParamInt(&amp;quot;id&amp;quot;)
    if err != nil {
        log.Println(err)
    }

    tag := find(id)
    if tag.ID == 0 {
        c.JSON(iris.StatusNotFound, map[string]string{&amp;quot;error&amp;quot;: &amp;quot;Tag not found.&amp;quot;})
    } else {
        c.JSON(iris.StatusOK, tag)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;podsumowanie&#34;&gt;Podsumowanie&lt;/h2&gt;

&lt;p&gt;Jak widać Iris sporo upraszcza, standardowe handlery z paczki net/http
przyjmują dwa parametry, request oraz response. W Iris to jest tylko jeden
wskaźnik na kontekst. Odczytanie parametru w url, konwersja do typu
całkowitego, odczytanie formatu json z body zapytania POST, zwrócenie jsona
z odpowiednim nagłówkiem statusu i wiele wiele innych standardowych operacji
staje się dużo łatwiejszych.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go: odbiorca metody, przykłady</title>
      <link>http://practical-coder.github.io/notatki/post/go-odbiorca-metody-przyk%C5%82ady/</link>
      <pubDate>Sun, 19 Jun 2016 09:03:31 +0200</pubDate>
      
      <guid>http://practical-coder.github.io/notatki/post/go-odbiorca-metody-przyk%C5%82ady/</guid>
      <description>&lt;p&gt;W Go po słowie kluczowym &lt;strong&gt;&lt;code&gt;func&lt;/code&gt;&lt;/strong&gt;, a przed nazwą metody, możemy określić jej odbiorcę.
Jeżeli obiekt nie będzie modyfikowany, odbiorcę metody określamy przez jego wartość.
W metodach &lt;strong&gt;&lt;code&gt;Len()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;Cap()&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;IsEmpty()&lt;/code&gt;&lt;/strong&gt; oraz &lt;strong&gt;&lt;code&gt;Top()&lt;/code&gt;&lt;/strong&gt; odbiorcą jest &lt;strong&gt;&lt;code&gt;Stack&lt;/code&gt;&lt;/strong&gt;. Potrzebują one informacji o aktualnym stanie obiektu tylko do odczytu.
Natomiast jeżeli metoda modyfikuje obiekt, wtedy odbiorca określany jest wskaźnikiem do obiektu.
Tak się dzieje w metodach &lt;strong&gt;&lt;code&gt;Push()&lt;/code&gt;&lt;/strong&gt; i &lt;strong&gt;&lt;code&gt;Pop()&lt;/code&gt;&lt;/strong&gt;. Tam odbiorcą jest &lt;strong&gt;&lt;code&gt;*Stack&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package stack

import &amp;quot;errors&amp;quot;

type Stack []interface{}

func (stack Stack) Len() int {
    return len(stack)
}

func (stack Stack) Cap() int {
    return cap(stack)
}

func (stack Stack) IsEmpty() bool {
    return len(stack) == 0
}

func (stack Stack) Top() (interface{}, error) {
    if stack.IsEmpty() {
        return nil, errors.New(&amp;quot;Cannot Top() an empty stack&amp;quot;)
    } else {
        return stack[len(stack)-1], nil
    }
}

func (stack *Stack) Push(x interface{}) {
    *stack = append(*stack, x)
}

func (stack *Stack) Pop() (interface{}, error) {
    tempStack := *stack
    if tempStack.IsEmpty() {
        return nil, errors.New(&amp;quot;Cannot Pop() an empty stack&amp;quot;)
    } else {
        item := tempStack[len(tempStack)-1]
        *stack = tempStack[:len(tempStack)-1]
        return item, nil
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>